<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> map_vs_object · 博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="map_vs_object - Etsuyou"><meta name="keywords"><meta name="author" content="Etsuyou"><link rel="short icon" href="https://s21.ax1x.com/2024/06/25/pksdM3F.png"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://etsuyou.github.io/atom.xml" title="博客"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://s21.ax1x.com/2024/06/25/pksdM3F.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="首页" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/categories/blog/" target="_self" data-hover="博客" class="nav-list-link">博客</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><Index>Page</Index><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">map_vs_object</h1><div class="post-info">2024-06-26<p id="busuanzi_container_page_pv" class="visit"><span id="busuanzi_value_page_pv"> </span><span>次访问</span></p></div><div class="post-content"><p>在 JavaScript 中，<code>Map</code> 和对象（<code>Object</code>）都是用于存储键值对的数据结构，但它们有一些关键的区别和各自的使用场景。以下是详细的比较：</p>
<span id="more"></span>

<h3 id="1-键的类型"><a href="#1-键的类型" class="headerlink" title="1. 键的类型"></a>1. 键的类型</h3><ul>
<li><p><strong>对象（Object）</strong>：对象的键必须是字符串或符号（Symbol）。如果使用其他类型（如数字或对象）作为键，会被自动转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;value&quot;</span>; <span class="comment">// 键被转换为字符串 &#x27;1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="number">1</span>]); <span class="comment">// 输出 &#x27;value&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Map</strong>：<code>Map</code> 允许任何类型的键，包括对象、函数、原始类型等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;&#125;;</span><br><span class="line">map.<span class="title function_">set</span>(keyObj, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(keyObj)); <span class="comment">// 输出 &#x27;value&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-键的顺序"><a href="#2-键的顺序" class="headerlink" title="2. 键的顺序"></a>2. 键的顺序</h3><ul>
<li><p><strong>对象（Object）</strong>：对象的键是无序的，尽管在现代 JavaScript 引擎中，键的插入顺序通常会被保留，但这不是规范保证的行为。</p>
</li>
<li><p><strong>Map</strong>：<code>Map</code> 保留键的插入顺序，迭代时会按照插入的顺序返回键值对。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value); <span class="comment">// 按照 &#x27;a&#x27;, &#x27;b&#x27; 的顺序输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h3><ul>
<li><strong>对象（Object）</strong>：对象在处理频繁的添加和删除操作时可能会有性能问题，特别是当对象变得非常大时。</li>
<li><strong>Map</strong>：<code>Map</code> 在频繁的增删操作中通常表现得更好，因为它是专门为这种用途设计的。</li>
</ul>
<h3 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h3><ul>
<li><p><strong>对象（Object）</strong>：对象有原型链，可能会继承原型链上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">toString</span>); <span class="comment">// 输出 `function toString() &#123; [native code] &#125;`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Map</strong>：<code>Map</code> 没有原型链问题，所有键值对都存储在 <code>Map</code> 实例中，不会从原型链继承属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">toString</span>); <span class="comment">// 输出 `undefined`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-大小"><a href="#5-大小" class="headerlink" title="5. 大小"></a>5. 大小</h3><ul>
<li><p><strong>对象（Object）</strong>：没有直接的方法获取对象的大小（键值对的数量），通常需要手动计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span>); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Map</strong>：<code>Map</code> 提供了 <code>size</code> 属性，可以直接获取键值对的数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. 使用场景</h3><ul>
<li><strong>对象（Object）</strong>：适用于需要简单键值对存储且键为字符串的场景，或需要使用 JSON 序列化的场景。</li>
<li><strong>Map</strong>：适用于需要频繁增删键值对、键可以是任意类型、需要保持键的插入顺序的场景。</li>
</ul>
<h3 id="7-其他特性"><a href="#7-其他特性" class="headerlink" title="7. 其他特性"></a>7. 其他特性</h3><ul>
<li><strong>对象（Object）</strong>：对象可以通过字面量语法 <code>&#123;&#125;</code> 创建，非常简洁。</li>
<li><strong>Map</strong>：<code>Map</code> 提供了更多的方法，如 <code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code>、<code>clear</code>、<code>forEach</code> 等，功能更丰富。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>对象示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;value1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&quot;key1&quot;</span>]); <span class="comment">// 输出 &#x27;value1&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> obj[<span class="string">&quot;key1&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;key1&quot;</span> <span class="keyword">in</span> obj); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>Map 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// 输出 &#x27;value1&#x27;</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>综上所述，选择使用 <code>Map</code> 还是对象（<code>Object</code>）取决于具体的需求和使用场景：如果需要复杂的键类型和更高的性能，<code>Map</code> 是更好的选择；如果只需要简单的字符串键值对存储，对象（<code>Object</code>）可能更方便。</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2024/06/26/store/RESTful/" title="RESTful" class="prev">上一篇</a><a href="/2024/06/26/store/CORS/" title="CORS" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2024 <a target="_blank">Etsuyou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>