{"meta":{"title":"博客","subtitle":"","description":"","author":"Etsuyou","url":"https://github.com","root":"/"},"pages":[],"posts":[{"title":"Nginx笔记","slug":"Nginx笔记","date":"2024-06-26T02:27:22.000Z","updated":"2024-06-26T02:41:23.139Z","comments":true,"path":"2024/06/26/Nginx笔记/","permalink":"https://github.com/2024/06/26/Nginx%E7%AC%94%E8%AE%B0/","excerpt":"123456789101112131415161718# 查看Nginx进程，一般可以看到master和worker进程ps -ef | grep nginx# 查看端口占用sudo lsof -i:80# 控制Nginx，-s singalnginx -s [...这里参数看下面表格]# 启动nginxsudo nginx# 查看路径信息# --conf-path= ... // 配置路径，和安装方式，操作系统有关nginx -Vsudo nginx -t // 也可以看到配置路径code ... // vscode 打开配置文件","text":"123456789101112131415161718# 查看Nginx进程，一般可以看到master和worker进程ps -ef | grep nginx# 查看端口占用sudo lsof -i:80# 控制Nginx，-s singalnginx -s [...这里参数看下面表格]# 启动nginxsudo nginx# 查看路径信息# --conf-path= ... // 配置路径，和安装方式，操作系统有关nginx -Vsudo nginx -t // 也可以看到配置路径code ... // vscode 打开配置文件 命令 描述 nginx -s stop 快速关闭 Nginx，可能不保存相关信息，并迅速终止 web 服务。（立即停止） nginx -s quit 平稳关闭 Nginx，保存相关信息，有安排的结束 web 服务。(优雅停止) nginx -s reload 因改变了 Nginx 相关配置，需要重新加载配置而重载。 nginx -s reopen 重新打开日志文件。 nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t 不运行，仅仅测试配置文件。Nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v 显示 Nginx 的版本。 nginx -V 显示 Nginx 的版本，编译器版本和配置参数。 配置文件12345# sites-availablelocation / &#123; # 默认的根路径，修改这个就可以 root /var/www/html;&#125; 复制文件1sudo cp -rfa ./etsuyou.github.io/* /var/www/site1 部署在一个 80 端口的公网 IP 上部署多个静态网页，可以通过以下几种方法实现： 方法一：使用 Nginx 反向代理和虚拟主机Nginx 是一个高性能的 HTTP 服务器和反向代理服务器，可以通过配置虚拟主机来实现多个静态网页的托管。 步骤 安装 Nginx在 Ubuntu 上安装 Nginx： 12sudo apt updatesudo apt install nginx 配置虚拟主机在 Nginx 的配置目录中为每个静态网页创建一个配置文件。例如，假设你有两个静态网页 site1 和 site2。 创建两个配置文件： 12sudo nano /etc/nginx/sites-available/site1sudo nano /etc/nginx/sites-available/site2 配置文件内容示例： site1 的配置文件 (/etc/nginx/sites-available/site1)： 12345678910server &#123; listen 80; server_name site1.example.com; location / &#123; root /var/www/site1; index index.html; &#125;&#125; 参考 123456789server &#123; listen 80; server_name interview.pages.etsuyou.cn; location / &#123; root /var/www/interview; index index.html; &#125;&#125; 创建符号链接将这些配置文件的符号链接放到 sites-enabled 目录下： 1sudo ln -s /etc/nginx/sites-available/site1 /etc/nginx/sites-enabled/ 创建网页目录并放置静态文件创建静态网页的目录并放置你的 HTML 文件： 123456sudo mkdir -p /var/www/site1sudo mkdir -p /var/www/site2# 将你的静态网页文件放到相应的目录中sudo cp /path/to/your/site1/* /var/www/site1/sudo cp /path/to/your/site2/* /var/www/site2/ 检查 Nginx 配置并重启服务检查 Nginx 配置是否正确： 1sudo nginx -t 如果配置正确，重启 Nginx 服务： 1sudo systemctl restart nginx 配置 DNS确保你的域名 site1.example.com 和 site2.example.com 都指向你的公网 IP 地址。 方法二：使用子目录如果不想使用域名，可以通过子目录来区分不同的静态网页。 步骤 配置 Nginx编辑默认的 Nginx 配置文件： 1sudo nano /etc/nginx/sites-available/default 添加子目录配置： 1234567891011121314server &#123; listen 80; server_name your_public_ip; location /site1/ &#123; alias /var/www/site1/; index index.html; &#125; location /site2/ &#123; alias /var/www/site2/; index index.html; &#125;&#125; 创建网页目录并放置静态文件创建静态网页的目录并放置你的 HTML 文件： 123456sudo mkdir -p /var/www/site1sudo mkdir -p /var/www/site2# 将你的静态网页文件放到相应的目录中sudo cp /path/to/your/site1/* /var/www/site1/sudo cp /path/to/your/site2/* /var/www/site2/ 检查 Nginx 配置并重启服务检查 Nginx 配置是否正确： 1sudo nginx -t 如果配置正确，重启 Nginx 服务： 1sudo systemctl restart nginx 访问静态网页现在你可以通过以下 URL 访问你的静态网页： http://your_public_ip/site1/ http://your_public_ip/site2/ 通过以上方法，你可以在一个 80 端口的公网 IP 上部署多个静态网页。选择使用虚拟主机还是子目录取决于你的具体需求和域名配置。","categories":[],"tags":[]},{"title":"RESTful","slug":"RESTful","date":"2024-06-26T01:43:57.000Z","updated":"2024-06-26T01:44:23.826Z","comments":true,"path":"2024/06/26/RESTful/","permalink":"https://github.com/2024/06/26/RESTful/","excerpt":"RESTful 是一种基于 HTTP 协议的架构风格，用于设计网络应用程序的 API。REST 代表 Representational State Transfer（表述性状态转移），它强调使用标准 HTTP 方法（如 GET、POST、PUT、DELETE 等）来操作资源。","text":"RESTful 是一种基于 HTTP 协议的架构风格，用于设计网络应用程序的 API。REST 代表 Representational State Transfer（表述性状态转移），它强调使用标准 HTTP 方法（如 GET、POST、PUT、DELETE 等）来操作资源。 RESTful API 的基本原则1. 资源（Resources） 资源是网络上的对象，如用户、订单、商品等。每个资源通过一个 URI（统一资源标识符）进行标识。 例如，用户资源可以通过 /users 进行访问，特定用户可以通过 /users/&#123;id&#125; 进行访问。 2. HTTP 方法（HTTP Methods） 使用标准的 HTTP 方法来操作资源： GET：读取资源 POST：创建资源 PUT：更新资源 DELETE：删除资源 PATCH：部分更新资源 3. 无状态（Stateless） 每个请求都是独立的，服务器不存储客户端的状态。所有需要的状态信息都包含在请求中。 4. 统一接口（Uniform Interface） 通过一致的方式访问和操作资源，这包括统一的资源标识、资源操作方法、资源表示格式等。 5. 表示（Representations） 资源可以有多种表示形式，如 JSON、XML、HTML 等。客户端和服务器通过内容协商（Content Negotiation）确定使用哪种表示格式。 6. 可缓存（Cacheable） 服务器响应应指明是否可以缓存，缓存机制可以提高性能。 RESTful API 示例假设我们有一个管理用户的 RESTful API，以下是一些示例请求及其含义： 1. 获取所有用户1GET /users 响应： 1234[ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot; &#125;] 2. 获取特定用户1GET /users/1 响应： 1&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot; &#125; 3. 创建新用户1POST /users 请求体： 1&#123; &quot;name&quot;: &quot;Charlie&quot; &#125; 响应： 12201 CreatedLocation: /users/3 响应体： 1&#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;Charlie&quot; &#125; 4. 更新用户信息1PUT /users/1 请求体： 1&#123; &quot;name&quot;: &quot;Alice Smith&quot; &#125; 响应： 1200 OK 响应体： 1&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Alice Smith&quot; &#125; 5. 删除用户1DELETE /users/1 响应： 1204 No Content RESTful API 的优点 简单性：使用标准的 HTTP 方法和状态码，易于理解和实现。 灵活性：资源可以有多种表示形式，客户端和服务器可以独立演化。 可扩展性：通过 URI 结构和查询参数，可以轻松扩展 API。 RESTful API 的设计建议 使用名词表示资源：URI 应该使用名词而不是动词。例如，使用 /users 而不是 /getUsers。 使用合适的 HTTP 方法：根据操作类型选择合适的 HTTP 方法。 使用状态码表示响应状态：如 200 OK、201 Created、204 No Content、404 Not Found 等。 提供有意义的错误信息：在错误响应中提供详细的错误信息，帮助客户端理解问题。 RESTful 的特点RESTful 的主要特点包括： 1. 资源导向 在 REST 中，所有的内容都是资源，每个资源都有一个唯一的 URI（统一资源标识符）。通过 URI 来标识资源。 2. 无状态性 每个请求从客户端到服务器必须包含理解该请求所需的所有信息。服务器不存储客户端的上下文，所有状态信息都保存在客户端。 3. 统一接口 RESTful 服务使用标准的 HTTP 方法（如 GET、POST、PUT、DELETE）来执行操作。每种方法对应一种操作类型： GET：检索资源 POST：创建资源 PUT：更新资源 DELETE：删除资源 4. 表现层状态转移 客户端与服务器之间的交互通过资源的表述（Representation）来进行。表述可以是 JSON、XML、HTML 等格式。 5. 可缓存性 服务器响应应指示响应是否是可缓存的，以提高性能。 6. 分层系统 客户端通常不知道它是否直接连接到最终的服务器，还是连接到中间服务器（如代理服务器）。 7. 按需代码（可选） 在某些情况下，服务器可以通过传输可执行代码（如 JavaScript）到客户端来扩展功能。 RESTful 服务示例RESTful 服务的一个典型示例是一个博客系统的 API，可能包含以下 URI 和操作： GET /posts：获取所有博客文章 GET /posts/&#123;id&#125;：获取特定 ID 的博客文章 POST /posts：创建一篇新的博客文章 PUT /posts/&#123;id&#125;：更新特定 ID 的博客文章 DELETE /posts/&#123;id&#125;：删除特定 ID 的博客文章 总结RESTful 是一种广泛应用于现代 Web 开发的架构风格，通过遵循其原则和最佳实践，可以设计出简洁、灵活和可扩展的 API。它的主要优点包括简单性、灵活性和可扩展性，使得 RESTful API 成为现代 Web 服务设计的主流选择。 参考文献 https://www.runoob.com/w3cnote/restful-architecture.html https://www.ruanyifeng.com/blog/2011/09/restful.html https://apisix.apache.org/zh/blog/2023/02/08/what-is-restful-api/","categories":[],"tags":[]},{"title":"map_vs_object","slug":"map_vs_object","date":"2024-06-26T01:43:07.000Z","updated":"2024-06-26T01:43:40.661Z","comments":true,"path":"2024/06/26/map_vs_object/","permalink":"https://github.com/2024/06/26/map_vs_object/","excerpt":"在 JavaScript 中，Map 和对象（Object）都是用于存储键值对的数据结构，但它们有一些关键的区别和各自的使用场景。以下是详细的比较：","text":"在 JavaScript 中，Map 和对象（Object）都是用于存储键值对的数据结构，但它们有一些关键的区别和各自的使用场景。以下是详细的比较： 1. 键的类型 对象（Object）：对象的键必须是字符串或符号（Symbol）。如果使用其他类型（如数字或对象）作为键，会被自动转换为字符串。 123const obj = &#123;&#125;;obj[&quot;1&quot;] = &quot;value&quot;; // 键被转换为字符串 &#x27;1&#x27;console.log(obj[1]); // 输出 &#x27;value&#x27; Map：Map 允许任何类型的键，包括对象、函数、原始类型等。 1234const map = new Map();const keyObj = &#123;&#125;;map.set(keyObj, &quot;value&quot;);console.log(map.get(keyObj)); // 输出 &#x27;value&#x27; 2. 键的顺序 对象（Object）：对象的键是无序的，尽管在现代 JavaScript 引擎中，键的插入顺序通常会被保留，但这不是规范保证的行为。 Map：Map 保留键的插入顺序，迭代时会按照插入的顺序返回键值对。 123456const map = new Map();map.set(&quot;a&quot;, 1);map.set(&quot;b&quot;, 2);for (let [key, value] of map) &#123; console.log(key, value); // 按照 &#x27;a&#x27;, &#x27;b&#x27; 的顺序输出&#125; 3. 性能 对象（Object）：对象在处理频繁的添加和删除操作时可能会有性能问题，特别是当对象变得非常大时。 Map：Map 在频繁的增删操作中通常表现得更好，因为它是专门为这种用途设计的。 4. 原型链 对象（Object）：对象有原型链，可能会继承原型链上的属性。 12const obj = &#123;&#125;;console.log(obj.toString); // 输出 `function toString() &#123; [native code] &#125;` Map：Map 没有原型链问题，所有键值对都存储在 Map 实例中，不会从原型链继承属性。 12const map = new Map();console.log(map.toString); // 输出 `undefined` 5. 大小 对象（Object）：没有直接的方法获取对象的大小（键值对的数量），通常需要手动计算。 12const obj = &#123; a: 1, b: 2 &#125;;console.log(Object.keys(obj).length); // 输出 2 Map：Map 提供了 size 属性，可以直接获取键值对的数量。 1234const map = new Map();map.set(&quot;a&quot;, 1);map.set(&quot;b&quot;, 2);console.log(map.size); // 输出 2 6. 使用场景 对象（Object）：适用于需要简单键值对存储且键为字符串的场景，或需要使用 JSON 序列化的场景。 Map：适用于需要频繁增删键值对、键可以是任意类型、需要保持键的插入顺序的场景。 7. 其他特性 对象（Object）：对象可以通过字面量语法 &#123;&#125; 创建，非常简洁。 Map：Map 提供了更多的方法，如 set、get、has、delete、clear、forEach 等，功能更丰富。 示例代码对象示例： 12345const obj = &#123;&#125;;obj[&quot;key1&quot;] = &quot;value1&quot;;console.log(obj[&quot;key1&quot;]); // 输出 &#x27;value1&#x27;delete obj[&quot;key1&quot;];console.log(&quot;key1&quot; in obj); // 输出 false Map 示例： 12345const map = new Map();map.set(&quot;key1&quot;, &quot;value1&quot;);console.log(map.get(&quot;key1&quot;)); // 输出 &#x27;value1&#x27;map.delete(&quot;key1&quot;);console.log(map.has(&quot;key1&quot;)); // 输出 false 综上所述，选择使用 Map 还是对象（Object）取决于具体的需求和使用场景：如果需要复杂的键类型和更高的性能，Map 是更好的选择；如果只需要简单的字符串键值对存储，对象（Object）可能更方便。","categories":[],"tags":[]},{"title":"CORS","slug":"CORS","date":"2024-06-26T01:42:20.000Z","updated":"2024-06-26T01:42:42.558Z","comments":true,"path":"2024/06/26/CORS/","permalink":"https://github.com/2024/06/26/CORS/","excerpt":"CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种浏览器机制，用于允许或限制从一个域（源）向另一个域（源）发起的请求。它通过设置 HTTP 头来控制哪些跨域请求是被允许的。","text":"CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种浏览器机制，用于允许或限制从一个域（源）向另一个域（源）发起的请求。它通过设置 HTTP 头来控制哪些跨域请求是被允许的。 背景由于安全原因，浏览器默认阻止网页发起跨域请求。CORS 是一种安全策略，允许服务器声明哪些来源可以访问其资源，从而实现跨域请求。 CORS 的基本概念 Origin（源）：由协议、域名和端口组成。比如，https://example.com:443 是一个源。 Preflight Request（预检请求）：对于某些类型的跨域请求（如使用 PUT 或 DELETE 方法，或自定义的请求头），浏览器会先发送一个 OPTIONS 请求，以确定服务器是否允许实际请求。 CORS 的工作流程 简单请求：如果是简单请求（如使用 GET 或 POST 方法且不包含自定义头部），浏览器直接发送请求，并在请求头中包含 Origin 头部。 预检请求：对于复杂请求，浏览器会先发送一个 OPTIONS 请求，包含 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 头部。服务器响应后，浏览器根据响应头决定是否发送实际请求。 关键 HTTP 头 请求头： Origin：表示发起请求的源。 Access-Control-Request-Method：预检请求中使用，表示实际请求使用的方法。 Access-Control-Request-Headers：预检请求中使用，表示实际请求包含的自定义头部。 响应头： Access-Control-Allow-Origin：表示允许哪些源访问资源。可以是具体的源（如 https://example.com）或通配符 *（允许所有源）。 Access-Control-Allow-Methods：表示允许哪些 HTTP 方法（如 GET, POST, PUT 等）。 Access-Control-Allow-Headers：表示允许哪些自定义请求头。 Access-Control-Allow-Credentials：表示是否允许发送凭据（如 cookies）。 Access-Control-Expose-Headers：表示哪些头部可以暴露给浏览器。 Access-Control-Max-Age：表示预检请求的结果可以缓存多长时间（秒）。 示例简单请求客户端请求： 123GET /api/data HTTP/1.1Host: api.example.comOrigin: https://example.com 服务器响应： 12345HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comContent-Type: application/json&#123; &quot;data&quot;: &quot;example data&quot; &#125; 预检请求客户端预检请求： 12345OPTIONS /api/data HTTP/1.1Host: api.example.comOrigin: https://example.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: Content-Type 服务器响应： 12345HTTP/1.1 204 No ContentAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: Content-TypeAccess-Control-Max-Age: 86400 实际请求： 123456PUT /api/data HTTP/1.1Host: api.example.comOrigin: https://example.comContent-Type: application/json&#123; &quot;data&quot;: &quot;new data&quot; &#125; 服务器响应： 12345HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comContent-Type: application/json&#123; &quot;data&quot;: &quot;new data&quot; &#125; 总结CORS 是一种浏览器机制，用于控制跨域请求的安全性。通过设置适当的 HTTP 头，服务器可以声明哪些源可以访问其资源，从而实现安全的跨域资源共享。在开发 Web 应用时，理解和正确配置 CORS 对于确保应用的安全性和正确性至关重要。","categories":[],"tags":[]},{"title":"Bearer_Token","slug":"Bearer_Token","date":"2024-06-26T01:40:53.000Z","updated":"2024-06-26T01:41:11.689Z","comments":true,"path":"2024/06/26/Bearer_Token/","permalink":"https://github.com/2024/06/26/Bearer_Token/","excerpt":"Bearer Token 是一种用于身份验证的安全令牌，通常在 HTTP 请求中使用，以便在客户端和服务器之间传递认证信息。Bearer Token 是 OAuth 2.0 标准的一部分，并且在许多现代 Web 应用程序中广泛使用。","text":"Bearer Token 是一种用于身份验证的安全令牌，通常在 HTTP 请求中使用，以便在客户端和服务器之间传递认证信息。Bearer Token 是 OAuth 2.0 标准的一部分，并且在许多现代 Web 应用程序中广泛使用。 Bearer Token 的基本概念 Bearer：表示持有者。Bearer Token 的持有者被认为是经过身份验证的用户或应用程序。 Token：一个字符串，通常是随机生成的，携带用户的认证信息。 Bearer Token 的工作原理 获取 Token：客户端（如 Web 应用、移动应用）通过某种方式（如用户名密码、OAuth 认证等）向认证服务器请求获取 Bearer Token。 携带 Token：客户端在后续的每个请求中，将 Bearer Token 放在 HTTP 请求头中，通常是 Authorization 头。 验证 Token：服务器接收到请求后，验证 Bearer Token 的有效性。如果 Token 有效，服务器将允许访问受保护的资源；否则，返回未授权的错误。 Bearer Token 的使用示例获取 Token客户端通过认证服务器获取 Bearer Token 的请求示例： 12345POST /oauth/token HTTP/1.1Host: auth.example.comContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=user&amp;password=pass&amp;client_id=client&amp;client_secret=secret 服务器返回的响应示例： 12345&#123; &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;, &quot;token_type&quot;: &quot;Bearer&quot;, &quot;expires_in&quot;: 3600&#125; 使用 Token客户端在后续请求中携带 Bearer Token 的示例： 123GET /api/protected/resource HTTP/1.1Host: api.example.comAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Bearer Token 的优点 简洁：只需在请求头中包含一个 Token 字符串，易于实现和使用。 灵活：可以与多种身份验证机制结合使用，如 OAuth 2.0、OpenID Connect 等。 无状态：服务器不需要存储客户端的会话状态，Token 自带认证信息。 Bearer Token 的安全性 加密传输：始终通过 HTTPS 传输 Bearer Token，防止中间人攻击。 Token 有效期：Token 通常有一个有效期，过期后需要重新获取，减少被滥用的风险。 Token 撤销：支持 Token 撤销机制，允许在发现 Token 泄露或滥用时使其失效。 Token 范围：使用 Token 范围（scope）限制 Token 的权限，确保最小权限原则。 总结Bearer Token 是一种广泛使用的身份验证机制，特别是在 OAuth 2.0 认证框架中。它通过在 HTTP 请求头中携带一个 Token 字符串，简化了客户端和服务器之间的身份验证过程。尽管 Bearer Token 提供了简洁和灵活的优点，但在使用时必须注意安全性，确保 Token 的安全传输和管理。","categories":[],"tags":[]},{"title":"显示首屏是什么？","slug":"显示首屏是什么？","date":"2024-06-26T01:39:04.000Z","updated":"2024-06-26T01:39:28.338Z","comments":true,"path":"2024/06/26/显示首屏是什么？/","permalink":"https://github.com/2024/06/26/%E6%98%BE%E7%A4%BA%E9%A6%96%E5%B1%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"“显示首屏”是指在用户访问一个网页时，浏览器首先呈现给用户的内容。这通常是指页面的可见部分（即不需要滚动就能看到的部分）。首屏的加载速度对用户体验至关重要，因为它决定了用户在访问网站时的第一印象。","text":"“显示首屏”是指在用户访问一个网页时，浏览器首先呈现给用户的内容。这通常是指页面的可见部分（即不需要滚动就能看到的部分）。首屏的加载速度对用户体验至关重要，因为它决定了用户在访问网站时的第一印象。 为什么首屏重要？ 用户体验：用户更倾向于留在加载速度快的网站上。如果首屏加载时间过长，用户可能会选择离开。 SEO：搜索引擎（如 Google）考虑页面加载速度作为排名因素。较快的首屏加载时间有助于提升搜索引擎排名。 转换率：对于电商网站或其他需要用户操作的网站，较快的首屏加载时间通常会带来更高的转换率。 如何优化首屏加载时间？ **服务器端渲染 (SSR)**：如前所述，使用 SSR 可以在服务器上生成 HTML 内容，从而加快首屏的显示速度。 代码拆分：将 JavaScript 文件按需加载，避免一次性加载所有代码。 懒加载：延迟加载非首屏的图片和其他资源，确保首屏内容尽快显示。 压缩和优化资源：压缩 CSS、JavaScript 和图片文件，减少文件大小。 使用 CDN：通过内容分发网络 (CDN) 提供静态资源，加快资源加载速度。 预加载关键资源：使用 &lt;link rel=&quot;preload&quot;&gt; 标签预加载关键资源，如字体和关键 CSS 文件。 具体示例以下是一些具体的技术和方法，用于优化首屏加载时间： 1. 服务器端渲染 (SSR)使用 Nuxt.js 进行服务器端渲染： 12345export default &#123; ssr: true, target: &quot;server&quot;, // 其他配置&#125;; 2. 代码拆分在 Vue 项目中，可以使用动态导入来实现代码拆分： 1const Component = () =&gt; import(&quot;./Component.vue&quot;); 3. 懒加载图片使用 Vue 的 v-lazy 指令或其他懒加载库： 1&lt;img v-lazy=&quot;imageSrc&quot; alt=&quot;Description&quot; /&gt; 4. 压缩资源使用 Webpack 的插件来压缩 CSS 和 JavaScript： 12345678const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);module.exports = &#123; optimization: &#123; minimize: true, minimizer: [new TerserPlugin()], &#125;,&#125;; 5. 使用 CDN将静态资源托管到 CDN 上，并在 HTML 中引用： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.example.com/styles.css&quot; /&gt; 6. 预加载关键资源在 HTML 中使用 &lt;link rel=&quot;preload&quot;&gt; 标签： 12&lt;link rel=&quot;preload&quot; href=&quot;/path/to/critical.css&quot; as=&quot;style&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;/path/to/critical.js&quot; as=&quot;script&quot; /&gt; 通过这些方法，可以显著优化首屏加载时间，提升用户体验和网站性能。","categories":[],"tags":[]},{"title":"SPA是什么？","slug":"SPA是什么？","date":"2024-06-25T12:53:38.000Z","updated":"2024-06-26T01:01:42.643Z","comments":true,"path":"2024/06/25/SPA是什么？/","permalink":"https://github.com/2024/06/25/SPA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"SPA 是单页应用（Single Page Application）的缩写。单页应用是一种 web 应用结构，其中所有的功能和内容都在一个 HTML 页面中加载和动态更新，而不是在用户导航时重新加载整个页面。SPA 的核心思想是通过 JavaScript 来动态更新页面内容，从而提供更快的用户体验和更流畅的交互。","text":"SPA 是单页应用（Single Page Application）的缩写。单页应用是一种 web 应用结构，其中所有的功能和内容都在一个 HTML 页面中加载和动态更新，而不是在用户导航时重新加载整个页面。SPA 的核心思想是通过 JavaScript 来动态更新页面内容，从而提供更快的用户体验和更流畅的交互。 SPA 的特点 单个 HTML 页面：整个应用只有一个 HTML 页面，所有的内容和功能通过 JavaScript 动态加载和更新。 客户端渲染：大部分渲染工作在客户端（浏览器）进行，服务器主要负责提供数据 API。 更快的用户体验：由于不需要每次导航都重新加载整个页面，用户体验更加流畅。 路由管理：通过 JavaScript 来管理应用的路由，通常使用库如 Vue Router 或 React Router。 SPA 的优势 更快的响应速度：因为不需要每次导航都重新加载整个页面，响应速度更快。 流畅的用户体验：页面切换和数据更新更加流畅，用户体验更好。 减少服务器负载：服务器主要提供数据 API，减少了对服务器的压力。 更好的开发体验：现代前端框架和工具（如 Vue.js、React、Angular）提供了强大的开发工具和生态系统，提升了开发效率。 SPA 的挑战 SEO 问题：由于内容是通过 JavaScript 动态加载的，搜索引擎爬虫可能无法抓取页面内容，影响 SEO。 首屏加载时间：由于需要加载大量的 JavaScript 文件，可能导致首屏加载时间较长。 复杂的客户端逻辑：需要在客户端处理更多的逻辑，增加了开发和维护的复杂性。 Vue.js 中的 SPA 结构使用 Vue.js 创建 SPA 通常包括以下几个主要部分： 项目结构：典型的 Vue.js 项目结构如下： 1234567891011121314my-vue-app/├── public/│ └── index.html├── src/│ ├── assets/│ ├── components/│ ├── router/│ │ └── index.js│ ├── store/│ ├── views/│ ├── App.vue│ └── main.js├── package.json└── vue.config.js 路由管理：使用 Vue Router 来管理应用的路由。 12345678910111213141516// src/router/index.jsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;import About from &quot;../views/About.vue&quot;;const routes = [ &#123; path: &quot;/&quot;, component: Home &#125;, &#123; path: &quot;/about&quot;, component: About &#125;,];const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes,&#125;);export default router; 状态管理：使用 Pinia 或 Vuex 来管理应用的全局状态。 123456// src/store/index.js (使用 Pinia)import &#123; createPinia &#125; from &quot;pinia&quot;;const store = createPinia();export default store; 入口文件：在 main.js 中挂载 Vue 实例并配置路由和状态管理。 1234567// src/main.jsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;createApp(App).use(router).use(store).mount(&quot;#app&quot;); SPA 的优化 代码拆分：使用动态导入和 Webpack 的代码拆分功能，按需加载模块，减少首屏加载时间。 1const About = () =&gt; import(&quot;../views/About.vue&quot;); 懒加载组件：对于不需要立即加载的组件，使用懒加载。 12345import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;const AsyncComponent = defineAsyncComponent(() =&gt; import(&quot;./components/AsyncComponent.vue&quot;)); 服务端渲染 (SSR)：结合 SSR 技术（如使用 Nuxt.js），改善 SEO 和首屏加载时间。 通过这些方法，可以构建一个高性能的 SPA 应用，同时克服其固有的一些挑战。","categories":[],"tags":[]},{"title":"hexo博客语法速查","slug":"hexo博客语法速查","date":"2024-06-25T04:49:59.000Z","updated":"2024-06-25T07:50:16.885Z","comments":true,"path":"2024/06/25/hexo博客语法速查/","permalink":"https://github.com/2024/06/25/hexo%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/","excerpt":"文章变量文章变量可以定义在 md 文件的开头。可以定义文章的标题，时间，归档的标签，归档的分类，文章关键字，文章描述，文章出处以及文章的示例等。 1234567891011---title: hexo博客语法速查date: 2024-06-25 12:49:59tags: [技术, 速查, 笔记, 语法]desc: 一篇展示hexo的md语法格式的文章，主要用来自己速查keywords: 速查，语法，hexocategories: - blogfrom: https://hexo.io/zh-cn/# demo: ../../../demos/201703/background.html--- 文章摘要如果你想创建文章摘要用于向读者展示文章的核心内容，那么需要在文章摘要之后其他内容之前添加 HTML 注释标签 &lt;!--more--&gt; 1&lt;!-- more --&gt; 警告块使用警告块需要 div 标签和 tip 类名： 在ECMAScript5的strict模式下，这种情况的this已经被规定不会指向全局对象了，而是undefined 123&lt;div class=&quot;tip&quot;&gt; 在ECMAScript5的strict模式下，这种情况的this已经被规定不会指向全局对象了，而是undefined&lt;/div&gt; 链接 Coursera 上的深度学习课程 1- [Coursera 上的深度学习课程](https://www.coursera.org/learn/deep-learning)","text":"文章变量文章变量可以定义在 md 文件的开头。可以定义文章的标题，时间，归档的标签，归档的分类，文章关键字，文章描述，文章出处以及文章的示例等。 1234567891011---title: hexo博客语法速查date: 2024-06-25 12:49:59tags: [技术, 速查, 笔记, 语法]desc: 一篇展示hexo的md语法格式的文章，主要用来自己速查keywords: 速查，语法，hexocategories: - blogfrom: https://hexo.io/zh-cn/# demo: ../../../demos/201703/background.html--- 文章摘要如果你想创建文章摘要用于向读者展示文章的核心内容，那么需要在文章摘要之后其他内容之前添加 HTML 注释标签 &lt;!--more--&gt; 1&lt;!-- more --&gt; 警告块使用警告块需要 div 标签和 tip 类名： 在ECMAScript5的strict模式下，这种情况的this已经被规定不会指向全局对象了，而是undefined 123&lt;div class=&quot;tip&quot;&gt; 在ECMAScript5的strict模式下，这种情况的this已经被规定不会指向全局对象了，而是undefined&lt;/div&gt; 链接 Coursera 上的深度学习课程 1- [Coursera 上的深度学习课程](https://www.coursera.org/learn/deep-learning) 标题从 md 的二级标题开始。 评论插件Hexo-theme-bubuzou 评论插件由最开始的多说改成网易云跟帖，后面由于 8 月 1 号云跟帖暂停服务，所以现在又换成了畅言。请在 theme/_config.yml 文件中做如下配置: 1changyan: bubuzou 归档页面显示所有文章需要安装hexo-generator-archive插件支持，然后在全局的_config.yml里配置： 12345archive_generator: per_page: 0 yearly: false monthly: false daily: false","categories":[{"name":"blog","slug":"blog","permalink":"https://github.com/categories/blog/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"速查","slug":"速查","permalink":"https://github.com/tags/%E9%80%9F%E6%9F%A5/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"语法","slug":"语法","permalink":"https://github.com/tags/%E8%AF%AD%E6%B3%95/"}]}],"categories":[{"name":"blog","slug":"blog","permalink":"https://github.com/categories/blog/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"速查","slug":"速查","permalink":"https://github.com/tags/%E9%80%9F%E6%9F%A5/"},{"name":"笔记","slug":"笔记","permalink":"https://github.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"语法","slug":"语法","permalink":"https://github.com/tags/%E8%AF%AD%E6%B3%95/"}]}